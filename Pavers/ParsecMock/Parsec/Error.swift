//
//  Error.swift
//  ParsecMock
//
//  Created by Keith on 2018/6/27.
//  Copyright Â© 2018 Keith. All rights reserved.
//

import PaversFRP

/**
-- | This abstract data type represents parse error messages. There are
  -- four kinds of messages:
--
-- >  data Message = SysUnExpect String
-- >               | UnExpect String
-- >               | Expect String
-- >               | Message String
--
-- The fine distinction between different kinds of parse errors allows
-- the system to generate quite good error messages for the user. It
  -- also allows error messages that are formatted in different
-- languages. Each kind of message is generated by different combinators:
--
--     * A 'SysUnExpect' message is automatically generated by the
--       'Text.Parsec.Combinator.satisfy' combinator. The argument is the
--       unexpected input.
--
--     * A 'UnExpect' message is generated by the 'Text.Parsec.Prim.unexpected'
--       combinator. The argument describes the
--       unexpected item.
--
--     * A 'Expect' message is generated by the 'Text.Parsec.Prim.<?>'
--       combinator. The argument describes the expected item.
--
--     * A 'Message' message is generated by the 'fail'
--       combinator. The argument is some general parser message.
*/

public enum Message {
  /// library generated unexpect
  case sysUnExpect(String)
  /// unexpected something
  case unexpect(String)
  /// expecting something
  case expect(String)
  /// raw message
  case message(String)
}


extension Message {
  public var fromEnum: Int {
    switch self {
    case .sysUnExpect(_): return 0
    case .unexpect(_): return 1
    case .expect(_): return 2
    case .message(_): return 3
    }
  }
}

extension Message: Equatable {
  public static func == (lhs: Message, rhs: Message) -> Bool {
    return lhs.fromEnum == rhs.fromEnum
  }
}

extension Message: Comparable{
  public static func < (lhs: Message, rhs: Message) -> Bool {
    return lhs.fromEnum < rhs.fromEnum
  }
}

extension Message {
  public var message: String {
    switch self {
    case .sysUnExpect(let s): return s
    case .unexpect(let s): return s
    case .expect(let s): return s
    case .message(let s): return s
    }
  }
}

/**
 -- | The abstract data type @ParseError@ represents parse errors. It
 -- provides the source position ('SourcePos') of the error
 -- and a list of error messages ('Message'). A @ParseError@
 -- can be returned by the function 'Text.Parsec.Prim.parse'. @ParseError@ is an
 -- instance of the 'Show' and 'Eq' classes.
 */
public struct ParserError {
  public let pos: SourcePos
  public let msgs: [Message]
}

extension ParserError: Equatable{}

extension ParserError {
  public var errorIsUnknown: Bool {return self.msgs.isEmpty}
  
  public init(unknownErrorWith pos: SourcePos) {
    self.pos = pos
    self.msgs = []
  }
  
  public func add(error: Message) -> ParserError {
    return ParserError(pos: self.pos, msgs: self.msgs + [error])
  }
  
  public func set(sourcePos: SourcePos) -> ParserError {
    return ParserError(pos: sourcePos, msgs: self.msgs)
  }
  
  public func set(errorMessages: [Message]) -> ParserError {
    return ParserError(pos: self.pos, msgs: errorMessages)
  }
  
//  mergeError :: ParseError -> ParseError -> ParseError
//  mergeError e1@(ParseError pos1 msgs1) e2@(ParseError pos2 msgs2)
//  -- prefer meaningful errors
//  | null msgs2 && not (null msgs1) = e1
//  | null msgs1 && not (null msgs2) = e2
//  | otherwise
//  = case pos1 `compare` pos2 of
//  -- select the longest match
//  EQ -> ParseError pos1 (msgs1 ++ msgs2)
//  GT -> e1
//  LT -> e2
  public func merge(error: ParserError) -> ParserError {
    if error.msgs.isEmpty && !self.msgs.isEmpty {
      return self
    } else if self.msgs.isEmpty && !error.msgs.isEmpty {
      return error
    } else {
      if self.pos == error.pos {
        return ParserError(pos: self.pos, msgs: self.msgs + error.msgs)
      } else {
        return self.pos > error.pos ? self : error
      }
    }
  }
}

extension ParserError: CustomStringConvertible {
  public var description: String {
    return "\(self.pos): "
  }
}

public func showErrorMessage(msgOr: String,
                             msgUnknown: String,
                             msgExpecting: String,
                             msgUnexpected: String,
                             msgEndOfInput: String,
                             msgs: [Message]) -> String {
  guard !msgs.isEmpty else {return msgUnknown}
  
  
  let sysUnExpect = msgs.filter(curry((==))(Message.sysUnExpect("")))
  let unExpect = msgs.filter(curry((==))(Message.unexpect("")))
  let expect = msgs.filter(curry((==))(Message.expect("")))
  
  
  return ""
}
/// String -> [Message] -> String
private func showMany(pre: String, msgs: [Message], _ msgOr: String) -> String {
  let ss = clean(msgs.map{$0.message})
  guard !ss.isEmpty else {return ""}
  if pre.isEmpty {return commasOr(ss, msgOr)}
  else {return pre + " " + commasOr(ss, msgOr)}
}

private func commasOr(_ ms: [String], _ msgOr: String) -> String {
  guard !ms.isEmpty else {return ""}
  guard  ms.count > 1 else { return ms[0] }
  return commaSep( Array(ms.dropLast()) ) + " " + msgOr + " " + ms.last!
}

private let commaSep = curry(seperate)(",")

private func seperate(_ seperator: String, _ ss: [String]) -> String {
  guard !ss.isEmpty else {return ""}
  guard ss.count > 1 else { return ss[0]}
  return ss.dropFirst().reduce(ss[0]) { (acc, s) in acc + seperator + s }
}

private func clean(_ ss: [String]) -> [String] {
  return Array(Set(ss.filter{!$0.isEmpty}))
}


/**
 --  TODO
 -- < The standard function for showing error messages. Formats a list of
 --    error messages in English. This function is used in the |Show|
 --    instance of |ParseError <#ParseError>|. The resulting string will be
 --    formatted like:
 --
 --    |unexpected /{The first UnExpect or a SysUnExpect message}/;
 --    expecting /{comma separated list of Expect messages}/;
 --    /{comma separated list of Message messages}/
 
 showErrorMessages ::
 String -> String -> String -> String -> String -> [Message] -> String
 showErrorMessages msgOr msgUnknown msgExpecting msgUnExpected msgEndOfInput msgs
 | null msgs = msgUnknown
 | otherwise = concat $ map ("\n"++) $ clean $
 [showSysUnExpect,showUnExpect,showExpect,showMessages]
 where
 (sysUnExpect,msgs1) = span ((SysUnExpect "") ==) msgs
 (unExpect,msgs2)    = span ((UnExpect    "") ==) msgs1
 (expect,messages)   = span ((Expect      "") ==) msgs2
 
 showExpect      = showMany msgExpecting expect
 showUnExpect    = showMany msgUnExpected unExpect
 showSysUnExpect | not (null unExpect) ||
 null sysUnExpect = ""
 | null firstMsg    = msgUnExpected ++ " " ++ msgEndOfInput
 | otherwise        = msgUnExpected ++ " " ++ firstMsg
 where
 firstMsg  = messageString (head sysUnExpect)
 
 showMessages      = showMany "" messages
 
 -- helpers
 showMany pre msgs3 = case clean (map messageString msgs3) of
 [] -> ""
 ms | null pre  -> commasOr ms
 | otherwise -> pre ++ " " ++ commasOr ms
 
 commasOr []       = ""
 commasOr [m]      = m
 commasOr ms       = commaSep (init ms) ++ " " ++ msgOr ++ " " ++ last ms
 
 commaSep          = separate ", " . clean
 
 separate   _ []     = ""
 separate   _ [m]    = m
 separate sep (m:ms) = m ++ sep ++ separate sep ms
 
 clean             = nub . filter (not . null)
 */


